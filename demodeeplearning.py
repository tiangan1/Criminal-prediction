# -*- coding: utf-8 -*-
"""demoDeepLearning.ipynb

Automatically generated by Colaboratory.


# Deep Learning (CNN and LSTM) for Crime prediction
"""

import pandas as pd
import numpy as np

import os
from google.colab import drive
drive.mount('/content/drive')

# Go to folder with data
data_folder='/content/drive/My Drive/Colab Notebooks/Criminal_Prediction'
os.chdir(data_folder)

# read the whole data
df=pd.read_csv('NYPD.csv')
print('\n Total ' +str(df.shape[0]) +' observations and ' + str(df.shape[1]) + ' variables\n')
df.head()

df.CMPLNT_FR_DT

"""# Bookkeeping"""

t=[]
for i in df['CMPLNT_FR_DT']:
    t.append(i[-4:])
df['CMPLNT_FR_DT']=t

df.CMPLNT_FR_DT

t=[]
for i in df['CMPLNT_FR_TM']:
    t.append(int(i.split(':')[0])*3600+ int(i.split(':')[1])*60)
df['CMPLNT_FR_TM']=t
t=[]
df['CMPLNT_TO_TM']=df['CMPLNT_TO_TM'].fillna(0)
for i in df['CMPLNT_TO_TM']:
    try:
        t.append(int(i.split(':')[0])*3600+ int(i.split(':')[1])*60)
    except:
        t.append(0)
df['CMPLNT_TO_TM']=t
df['TIME']=df['CMPLNT_TO_TM']-df['CMPLNT_FR_TM']
df=df.drop(['CMPLNT_TO_TM','CMPLNT_FR_TM','OFNS_DESC'],axis=1)

df['LAW_CAT_CD']=df['LAW_CAT_CD'].mask(df['LAW_CAT_CD']=='MISDEMEANOR',0)
df['LAW_CAT_CD']=df['LAW_CAT_CD'].mask(df['LAW_CAT_CD']=='FELONY',1)
df['LAW_CAT_CD']=df['LAW_CAT_CD'].mask(df['LAW_CAT_CD']=='VIOLATION',2)


df['CRM_ATPT_CPTD_CD']=df['CRM_ATPT_CPTD_CD'].mask(df['CRM_ATPT_CPTD_CD']=='ATTEMPTED',0)
df['CRM_ATPT_CPTD_CD']=df['CRM_ATPT_CPTD_CD'].mask(df['CRM_ATPT_CPTD_CD']=='COMPLETED',1)

df=df[df['LAW_CAT_CD']!=2]
print('\n Total ' +str(df.shape[0]) +' observations and ' + str(df.shape[1]) + ' variables\n')
df.head()

import collections
t=[]
obj=collections.Counter(df['PREM_TYP_DESC'])
for i in df['PREM_TYP_DESC']:
    if obj[i]>500:
        t.append(i)
    else:
        t.append('00000'+str(i))
df['PREM_TYP_DESC']=t

t=[]
for i in df['PREM_TYP_DESC']:
    if '00000' in i:
        if 'STORE' in i or 'SHOE'in i or 'JEWELRY' in i:
            t.append('stores')
        elif 'CHECK CASHING BUSINESS'in i or 'BANK'in i or 'ATM' in i or 'LOAN COMPANY' in i:
            t.append('bank')
        elif 'BUS' in i:
            t.append('bus')
        elif 'HIGHWAY' in i or 'BRIDGE'in i or 'TUNNEL' in i or 'TAXI' in i or 'TRAMWAY' in i or 'TRANSIT' in i:
            t.append('car')
        elif 'FERRY' in i or 'MARINA' in i:
            t.append('ferry')
        elif 'SCHOOL' in i:
            t.append('PUBLIC SCHOOL')
        elif 'MAILBOX'in i or 'PHOTO'in i or'BOOK'in i:
            t.append('card')
        elif 'WORSHIP'in i or'MOSQUE' in i or 'SYNAGOGUE' in i or 'CHURCH' in i or 'CEMETERY' in i:
            t.append('church')
        elif 'ABANDON'in i or'OPEN' in i or 'SITE' in i:
            t.append('site')
        elif 'WAREHOUSE'in i or 'STORAGE'in i:
            t.append('warehouse')
        elif 'DOCTOR'in i or 'HOSPITAL' in i:
            t.append('hospital')
        elif 'GYM'in i or 'SALON' in i:
            t.append('fitness')
        else:
            t.append(i)
    else:
        t.append(i)
df['PREM_TYP_DESC']=t

df=df.fillna(0) # fill missing values

# clean data 
y=df['CMPLNT_FR_DT']
df=df.drop(['CMPLNT_FR_DT'],axis=1)
target=df['LAW_CAT_CD']
df=df.drop('LAW_CAT_CD',axis=1)

df=pd.get_dummies(df)
df.head(2)

"""# Tsne & UMAP"""

data = df.copy()
data['LAW_CAT_CD'] = target

sample_data = data.sample(frac=0.05)
sample_data

# minmaxscaler data
from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()

norm_data = scaler.fit_transform(sample_data)

from sklearn.decomposition import PCA

pca = PCA()
pca_crime = pca.fit_transform(norm_data)

# Do LLE
from sklearn.manifold import LocallyLinearEmbedding as LLE

lle = LLE(n_neighbors=150, n_components=2)
lle_data = lle.fit_transform(norm_data)

from plotly.subplots import make_subplots
import plotly.graph_objects as go

m = sample_data['LAW_CAT_CD']==0
f = sample_data['LAW_CAT_CD']==1


fig = make_subplots(rows=2, cols=1, 
                    subplot_titles=("PCA", "LLE"))

# PCA
fig.add_trace(go.Scatter(
    x=pca_crime[m, 0],
    y=pca_crime[m, 1],
    mode="markers",
    name='MISDEMEANOR',
    marker_color='red',
    marker_symbol='circle',
),row=1, col=1)

fig.add_trace(go.Scatter(
    x=pca_crime[f, 0],
    y=pca_crime[f, 1],
    mode="markers",
    name='FELONY',
    marker_color='blue',
    marker_symbol='square',
),row=1, col=1)

# LLE
fig.add_trace(go.Scatter(
    x=lle_data[m, 0],
    y=lle_data[m, 1],
    mode="markers",
    name='MISDEMEANOR',
    marker_color='red',
    marker_symbol='circle',
),row=2, col=1)

fig.add_trace(go.Scatter(
    x=lle_data[f, 0],
    y=lle_data[f, 1],
    mode="markers",
    name='FELONY',
    marker_color='blue',
    marker_symbol='square',
),row=2, col=1)


# Update xaxis properties
fig.update_xaxes(title_text="$PC_{1}$", row=1, col=1)
fig.update_xaxes(title_text="$LLE_{1}$", row=2, col=1)


# Update yaxis properties
fig.update_yaxes(title_text="$PC_{2}$", row=1, col=1)
fig.update_yaxes(title_text="$LLE_{2}$", row=2, col=1)

# Edit layout
fig.update_layout(height=1000, width=1800,)

fig.show()

from sklearn.manifold import TSNE

tsne = TSNE(perplexity = 80, verbose=2)
tsne_data = tsne.fit_transform(norm_data)

# UMAP
import umap

umap_ = umap.UMAP(n_neighbors=80, metric='manhattan',
                  min_dist=0.06, spread=1.0)
umap_data = umap_.fit_transform(norm_data)

from plotly.subplots import make_subplots
import plotly.graph_objects as go

brook = sample_data.BORO_NM_BROOKLYN==1
manh = sample_data.BORO_NM_MANHATTAN==1
bronx = sample_data.BORO_NM_BRONX==1
queens = sample_data.BORO_NM_QUEENS==1
staten = sample_data['BORO_NM_STATEN ISLAND']==1

fig = make_subplots(rows=1, cols=2, 
                    subplot_titles=("T-SNE", "UMAP"))

fig.add_trace(go.Scatter(
    x=tsne_data[brook&f, 0],
    y=tsne_data[brook&f, 1],
    mode="markers",
    name='Brooklyn',
    marker_color='red',
    marker_size = 20,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=1)

fig.add_trace(go.Scatter(
    x=tsne_data[brook&m, 0],
    y=tsne_data[brook&m, 1],
    mode="markers",
    name='Brooklyn',
    marker_color='red',
    marker_size = 8,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=1)

fig.add_trace(go.Scatter(
    x=tsne_data[manh&f, 0],
    y=tsne_data[manh&f, 1],
    mode="markers",
    name='Manhattan',
    marker_color='green',
    marker_size = 20,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=1)

fig.add_trace(go.Scatter(
    x=tsne_data[manh&m, 0],
    y=tsne_data[manh&m, 1],
    mode="markers",
    name='Manhattan',
    marker_color='green',
    marker_size = 8,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=1)

fig.add_trace(go.Scatter(
    x=tsne_data[bronx&f, 0],
    y=tsne_data[bronx&f, 1],
    mode="markers",
    name='Bronx',
    marker_color='blue',
    marker_size = 20,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=1)

fig.add_trace(go.Scatter(
    x=tsne_data[bronx&m, 0],
    y=tsne_data[bronx&m, 1],
    mode="markers",
    name='Bronx',
    marker_color='blue',
    marker_size = 8,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=1)

fig.add_trace(go.Scatter(
    x=tsne_data[queens&f, 0],
    y=tsne_data[queens&f, 1],
    mode="markers",
    name='Queens',
    marker_color='pink',
    marker_size = 20,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=1)

fig.add_trace(go.Scatter(
    x=tsne_data[queens&m, 0],
    y=tsne_data[queens&m, 1],
    mode="markers",
    name='Queens',
    marker_color='pink',
    marker_size = 8,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=1)

fig.add_trace(go.Scatter(
    x=tsne_data[staten&f, 0],
    y=tsne_data[staten&f, 1],
    mode="markers",
    name='Staten Island',
    marker_color='yellow',
    marker_size = 20,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=1)

fig.add_trace(go.Scatter(
    x=tsne_data[staten&m, 0],
    y=tsne_data[staten&m, 1],
    mode="markers",
    name='Staten Island',
    marker_color='yellow',
    marker_size = 8,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=1)

fig.add_trace(go.Scatter(
    x=umap_data[brook&f, 0],
    y=umap_data[brook&f, 1],
    mode="markers",
    name='Brooklyn',
    marker_color='red',
    marker_size = 20,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=2)

fig.add_trace(go.Scatter(
    x=umap_data[brook&m, 0],
    y=umap_data[brook&m, 1],
    mode="markers",
    name='Brooklyn',
    marker_color='red',
    marker_size = 8,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=2)

fig.add_trace(go.Scatter(
    x=umap_data[manh&f, 0],
    y=umap_data[manh&f, 1],
    mode="markers",
    name='Manhattan',
    marker_color='green',
    marker_size = 20,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=2)

fig.add_trace(go.Scatter(
    x=umap_data[manh&m, 0],
    y=umap_data[manh&m, 1],
    mode="markers",
    name='Manhattan',
    marker_color='green',
    marker_size = 8,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=2)

fig.add_trace(go.Scatter(
    x=umap_data[bronx&f, 0],
    y=umap_data[bronx&f, 1],
    mode="markers",
    name='Bronx',
    marker_color='blue',
    marker_size = 20,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=2)

fig.add_trace(go.Scatter(
    x=umap_data[bronx&m, 0],
    y=umap_data[bronx&m, 1],
    mode="markers",
    name='Bronx',
    marker_color='blue',
    marker_size = 8,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=2)

fig.add_trace(go.Scatter(
    x=umap_data[queens&f, 0],
    y=umap_data[queens&f, 1],
    mode="markers",
    name='Queens',
    marker_color='pink',
    marker_size = 20,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=2)

fig.add_trace(go.Scatter(
    x=umap_data[queens&m, 0],
    y=umap_data[queens&m, 1],
    mode="markers",
    name='Queens',
    marker_color='pink',
    marker_size = 8,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=2)

fig.add_trace(go.Scatter(
    x=umap_data[staten&f, 0],
    y=umap_data[staten&f, 1],
    mode="markers",
    name='Staten Island',
    marker_color='yellow',
    marker_size = 20,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=2)

fig.add_trace(go.Scatter(
    x=umap_data[staten&m, 0],
    y=umap_data[staten&m, 1],
    mode="markers",
    name='Staten Island',
    marker_color='yellow',
    marker_size = 8,
    marker_line = dict(color='black',
                       width=1)
),row=1, col=2)

# Update xaxis properties
fig.update_xaxes(title_text="$t-SNE_{1}$", row=1, col=1)
fig.update_xaxes(title_text="$UMAP_{1}$", row=1, col=2)


# Update yaxis properties
fig.update_yaxes(title_text="$t-SNE_{2}$", row=1, col=1)
fig.update_yaxes(title_text="$UMAP_{2}$", row=1, col=2)

# Edit layout
fig.update_layout(height=800, width=1800,)

fig.show()

"""Training and test data partitioned in a time manner: early time data will be training. 2018 data will be test"""

# from sklearn.model_selection import train_test_split
# X_train,X_test,y_train,y_test=train_test_split(df,target, test_size=0.2,random_state=0)



X_test=df[ y == '2018' ]
y_test=target[y=='2018']
X_train=df[y!='2018']
y_train=target[y!='2018']

import keras
from keras.layers import Dense
from keras.models import Sequential
from keras.utils import to_categorical
from keras.optimizers import SGD 
from keras.callbacks import EarlyStopping
from keras.utils import np_utils
import itertools
from keras.layers import LSTM
from keras.layers.convolutional import Conv1D
from keras.layers.convolutional import MaxPooling1D
from keras.layers import Dropout

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train.loc[:]=StandardScaler().fit_transform(X_train.loc[:])
X_test.loc[:]=sc.fit_transform(X_test.loc[:])

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import roc_curve
from sklearn.metrics import auc
# Supervised transformation based on random forests
rf = RandomForestClassifier(max_depth=3, n_estimators=10)
rf.fit(X_train, y_train)

y_pred_rf = rf.predict_proba(X_test)[:, 1]
fpr_rf, tpr_rf, thresholds_rf = roc_curve(y_test, y_pred_rf)
auc_rf = auc(fpr_rf, tpr_rf)

auc_rf

X_train_1 = X_train.values.reshape((X_train.shape[0],  X_train.shape[1],1))
X_test_1= X_test.values.reshape((X_test.shape[0],  X_test.shape[1],1))
from keras.layers import Flatten
model = Sequential()

model.add(Conv1D(filters=256, kernel_size=2, activation='relu', input_shape=(X_train_1.shape[1], X_train_1.shape[2])))
model.add(Dropout(0.2))
model.add(MaxPooling1D(pool_size=2))
model.add(Conv1D(filters=128, kernel_size=2, activation='relu'))
model.add(Dropout(0.2))
model.add(MaxPooling1D(pool_size=2))
model.add(Conv1D(filters=32, kernel_size=2, activation='relu'))
model.add(Dropout(0.2))
model.add(MaxPooling1D(pool_size=2))
model.add(Conv1D(filters=10, kernel_size=2, activation='relu'))
model.add(Dropout(0.2))
model.add(MaxPooling1D(pool_size=2))

# model.add(MaxPooling1D(pool_size=2))
model.add(Flatten())
model.add(Dense(50))
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer='adam')

model.summary()

history = model.fit(X_train_1, y_train, epochs=20, batch_size=70, 
                    validation_data=(X_test_1, y_test), verbose=2, 
                    shuffle=False)

predicted=model.predict_classes(X_test_1)

from sklearn.metrics import accuracy_score,recall_score,precision_score
accuracy_score(y_test, predicted),recall_score(y_test,predicted),precision_score(y_test,predicted)

pd.Series(predicted.flatten()).value_counts()

y_pred_keras = predicted.ravel()
fpr_keras, tpr_keras, thresholds_keras = roc_curve(y_test, y_pred_keras)

auc_keras = auc(fpr_keras, tpr_keras)

X_train_2 = X_train.values.reshape((X_train.shape[0], 1, X_train.shape[1]))
X_test_2= X_test.values.reshape((X_test.shape[0], 1, X_test.shape[1]))

model = Sequential()
model.add(LSTM(200, input_shape=(X_train_2.shape[1], X_train_2.shape[2]),return_sequences=True))
model.add(Dropout(0.2))
model.add(LSTM(100,return_sequences=True))
model.add(Dropout(0.2))
model.add(LSTM(50,return_sequences=True))
model.add(Dropout(0.2))
model.add(LSTM(30,return_sequences=True))
model.add(Dropout(0.2))
model.add(LSTM(15))
model.add(Dropout(0.2))
model.add(Dense(10))
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer='adam')

history = model.fit(X_train_2, y_train, epochs=20, 
                    batch_size=70, validation_data=(X_test_2, y_test), 
                    verbose=2, shuffle=False)

predicted=model.predict_classes(X_test_2)

from sklearn.metrics import accuracy_score,recall_score,precision_score
accuracy_score(y_test, predicted),recall_score(y_test,predicted),precision_score(y_test,predicted)

y_pred_lstm = predicted.ravel()
fpr_lstm, tpr_lstm, thresholds_lstm = roc_curve(y_test, y_pred_lstm)

auc_lstm = auc(fpr_lstm, tpr_lstm)

from sklearn.ensemble import ExtraTreesClassifier
ex=ExtraTreesClassifier()
ex.fit(X_train,y_train)
ex.score(X_test,y_test)

from sklearn.metrics import recall_score,precision_score
precision_score(y_test, ex.predict(X_test),average="micro"),recall_score(y_test,ex.predict(X_test),average="micro")

y_pred_ex = ex.predict(X_test).ravel()
fpr_ex, tpr_ex, thresholds_ex = roc_curve(y_test, ex.predict(X_test))

auc_ex = auc(fpr_ex, tpr_ex)

from sklearn.metrics import confusion_matrix
confusion_matrix(y_test, ex.predict(X_test))

import matplotlib.pyplot as plt

plt.figure(figsize=(18,10))
plt.plot([0, 1], [0, 1], 'k--')
plt.plot(fpr_keras, tpr_keras, label='CNN (area = {:.3f})'.format(auc_keras))
plt.plot(fpr_lstm, tpr_lstm, label='LSTM (area = {:.3f})'.format(auc_lstm))
plt.plot(fpr_ex, tpr_ex, label='ExtraTree (area = {:.3f})'.format(auc_ex))
plt.plot(fpr_rf, tpr_rf, label='RF (area = {:.3f})'.format(auc_rf))
plt.xlabel('False positive rate')
plt.ylabel('True positive rate')
plt.title('ROC curve')
plt.legend(loc='best')
plt.grid('on')
plt.show()

plt.figure(figsize=(15,8))
plt.xlim(-0.05, 0.2)
plt.ylim(0.8, 1.05)
plt.plot([0, 1], [0, 1], 'k--')
plt.plot(fpr_keras, tpr_keras, label='CNN (area = {:.3f})'.format(auc_keras))
plt.plot(fpr_lstm, tpr_lstm, label='LSTM (area = {:.3f})'.format(auc_lstm))
plt.plot(fpr_ex, tpr_ex, label='ExtraTree (area = {:.3f})'.format(auc_ex))
plt.plot(fpr_rf, tpr_rf, label='RF (area = {:.3f})'.format(auc_rf))
plt.xlabel('False positive rate')
plt.ylabel('True positive rate')
plt.title('ROC curve (zoomed in at top left)')
plt.legend(loc='best')
plt.grid('on')
plt.show()

